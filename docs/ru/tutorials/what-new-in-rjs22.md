# Что нового в RightJS 2.2

RightJS 2.2 это следующее крупное обновление ядра и плагинов RightJS.
Оно приносит множество малых и крупных изменений, исправлений, оптимизаций
и естественно клевых маленьких фишек.

<%= anchors_index %>


## Поддержка нативных CSS трансформаций в эффектах, :fx

Нативные css-трансформации появились достаточно давно, они уже есть в
Safari, Chrome, FF4 и последних версиях Opera. Пришло время начать их
использовать по настоящему.

Начиная с версии 2.2 RightJS будет использовать встроенную поддержку
css-трансформаций для обработки анимации элементов в таких методах как
{Element#morph}, {Element#slide}, {Element#fade} и т.д.

На уровне API не произошло каких-либо существенных изменений, RightJS будет
автоматически определять если текущий браузер имеет встроенную поддержку
css-трансформаций и использовать их если возможно.

На данный момент мы используем поддержку встроенных css-трансформаций в
браузерах Safari, Chrome и FF4. Не смотря на то что Opera так же
поддерживает данную возможность, ее поддержка была отключена в этом браузере
в виду плохой производительности и ограниченных возможностей (не
поддерживаются некоторые стили).

Для работы с поддержкой встроенных css-трансформаций в модуле {Fx} появилась
дополнительная опция под названием `'engine'`. Вы можете установить ее в
`'javascript'`, для того чтобы заблокировать поддержку встроенной
функциональности, или же в `'native'` для того чтобы всегда использовать
встроенные css-трансформации, включая Opera.


## Класс Fx.Attr, :attr

Коллекция встроенных эффектов RightJS пополнилась новым классом {Fx.Attr},
который используется для плавного изменения атрибутов элементов. На данный
момент он подключен как родительский класс для {Fx.Scroll} для управления
полосами прокрутки, но в целом его можно использовать для работы с любыми
атрибутами имеющими численное значение.


## Улучшенный UJS, :ujs

Модуль UJS в RightJS был переработан во многих отношениях. Во-первых он был
оптимизирован для того чтобы предоставлять более быструю обработку событий,
а во-вторых, UJS слушатели событий теперь реагируют на события не только
непосредственно указанных элементов, но так же и любых вложенных в них узлов.

Например, скажем у вас есть следующая структура элементов

    <div class="something">
      <div class="corners">
        <div class="paddings">
          Собственно некий текст
        </div>
      </div>
    </div>

Если вы подключите UJS обработчик события на верхний элемент

    "div.something".onClick('toggleClass', 'clicked');

В предыдущих версиях RightJS обработчик срабатывал только на клики по самому
элементу не реагируя на события от вложенных элементов. Теперь эта проблема
была исправлена и UJS модуль предоставляет точно такую же стандартную
функциональность, что и обычные обработчики событий, подключенные
непосредственно к самим элементам страницы.


## Обработка mouseenter/mouseleave , :mouseio

Начиная с версии 2.2 RightJS будет предоставлять поддержку событий
`mouseenter` и `mouseleave` "из коробки", что очень удобно при
создании различных динамических меню, попапов и т.п. вещей.

В нашей реализации нет ничего специфического, нет необходимости ни в каких
дополнительных методах или чем либо еще, просто используйте имена
`'mouseenter'` и `'mouseleave'`, как вы делаете с любыми другими событиями
на странице

    $('element').on('mouseenter', func1);
    $('element').on('mouseleave', func2);

    // или с сокращениями
    $('element').onMouseenter(func1);
    $('element').onMouseleave(func2);

Данная возможность так же доступна с UJS

    "div.something".onMouseenter(func1);
    "div.something".onMouseleave(func2);


## DOM-шорткаты для строк, :shortcuts

Любой гуманоид опробовавший наши {String#on} шорткаты для работы с UJS
модулем, находит их странноватыми, но влюбляется в них с первого раза.
RightJS 2.2 расширяет данную фичу и теперь позволяет вам вызывать практически
любые методы dom-оберток непосредственно от строк.

В целом, у этой возможности есть две стороны. Во-первых когда вы вызываете
методы изменяющие элемент страницы, они будут вызваны на _всех_ подходящих
элементах.

    "div.something".addClass('boo-hoo');
    "div.something".update('Превед ведмед!');
    "div.something".highlight();
    "div.something".remove();
    // ...

Во-вторых, вы можете так же вызывать методы предназначенные для запроса
данных, в этом случае шорткат вернет данные от _первого_ подходящего элемента

    "div.something".get('id');  // -> String
    "div.something".parent();   // -> Element
    "div.something".children(); // -> Array
    // ...

В целом, идея та же самая что и в jQuery, так что, ежели вы умудрились
свернуть себе мозги об этот фреймворк, но потом впали в романтические
отношения с RightJS, новые шорткаты - это ваш шанс на счастье :)


## Слияние Class и Wrapper, :class

Когда dom-обертки были впервые представлены в RightJS 2.0, они эмулировали
модуль {Class} но при этом, по сути, представляли собой отдельно существующий
кусок кода специально предназначенный для работы с обертками.

В RightJS 2.2 dom-обертки и классы были объединены в одну универсальную
сруктуру с юнитом {Class} в качестве общего родительского класса.

Это дает нам несколько интересных возможностей. Во-первых теперь нет никакой
разницы между декларацией dom-оберток и обычных классов:

    var MyKlass = new Class({
      // ...
    });

    var MyElement = new Class(Element, {
      // ...
    });

Все они будут иметь совершенно одинаковый набор возможностей, например, теперь
вы можете использовать параметр `'prebind'` с dom-обертками

    var MyElement = new Class(Element, {
      'prebind': ['method1', 'method2'],

      method1: function() {},
      method2: function() {}
    });

Другой интересный результат объединения в том, что объект {Class} теперь
является общим родителем для всех классов в системе.

    var MyClass   = new Class({});
    var MyElement = new Class(Element, {});

    new MyClass('param') instanceof Class; // -> true
    new MyElement('div') instanceof Class; // -> true

Это позволяет например выяснить если некий объект построен на основе RightJS.
Или же, вы можете например делать глобальные изменения для всех классов в
системе в одном месте и т.п.


## Супервызовы на модулях, :supercalls

Еще одним результатом обновлений в модуле классов является то, что теперь
вы можете делать супервызовы на инжектированных модулях точно так же как на
унаследованных классах.

Общая идея тут в том, что иногда вам необходимо перегрузить какой либо
метод класса без использования наследования. RightJS позволяет это делать с
помощью инжекции функциональности через подключаемые модули, но вызов
оригинальных методов было делом достаточно хитрым и запутанным, нужно было
вручную сохранить оригиналы и затем вызывать их через `.apply` методы.

Эти грустные дни остались в прошлом. Теперь вы можете делать супервызовы
через `$super` метод, точно так же как это делается в случае наследования

    var MyClass = new Class({
      method: function() {
        return 'Оригинал';
      }
    });

    // подключаем первый модуль
    MyClass.include({
      method: function() {
        return this.$super() + '+Модуль1';
      }
    });

    // подключае еще один модуль
    MyClass.include({
      method: function() {
        return this.$super() + '+Модуль2';
      }
    });

    new MyClass().method(); // -> 'Оригинал+Модуль1+Модуль2'

Теперь это все работает аккуратно и удобно!


## Поддержка IE8 была перенесена в модуль olds, :ie8

Консилиум русских физиков ядерщиков постановил, что IE8 морально устарел и как
следствие его поддержка была переведена в модуль olds.

Существует несколько причин для данного решения. Во-первых IE8 имеет кучу
проблем с нормальной поддержкой CSS3 селекторов, во-вторых он так же как и все
предыдущие версии IE не поддерживает всплытие таких событий как `change` и
`submit`, и в третьих IE8 постоянно падает в IE7 режим и подгружает модуль
olds в любом случае.

В результате поддержка IE8 отныте будет в olds, а ядро RightJS теперь
представляет практически чистую w3c функциональность без каких либо IE хаков.


## Полная поддержка CSS3, :css3

С переводом поддержки IE8 в модуль olds, мы наконец смогли починить все
проблемы с полной поддержкой CSS3 стандартов, теперь все стандартные селекторы
поддерживаются на всех браузерах.


## Глубокое объединение в Object.merge, :object

Метод {Object.merge} был обновлен и теперь поддерживает глубокое объединение
объектов рекурсивно объединяя все вложенные объекты в одно целое.

    Object.merge(
      {a: {b: {c: 'd'}, e: 'f'}},
      {a: {b: {c: 'd', e: 'f'}}}
    );
    // -> {a: {b: {c: 'd', e: 'f'}, e: 'f'}}

Если вам нужна старая одно-уровневая функциональность, пожалуйста используйте
функцию `$ext` из модуля {Util}


## Метод Element#index, :index

В класс {Element} был добавлен новый метод {Element#index} который возвращает
индекс текущего элемента среди его соседей

    <ul>
      <li id="one">One</li>
      <li id="two">Two</li>
    </ul>

    $('one').index(); // -> 0
    $('two').index(); // -> 1


## Чистый DOM поиск, :search

Методы для dom-поиска, такие как {Element#find}, {Document#find} и функция
`$$` теперь могут производить чистый dom поиск без оборачивания результатов
поиска в объекты класса {Element}.

Для использования данной возможности просто передайте `true` в качестве
второго аргумента

    $('my-element').find('div.something', true); // -> [HTMLElement, ...]
    $(document).find('div.something', true);     // -> [HTMLElement, ...]

    // или так
    $$('div.something', true); // -> [HTMLElement, ...]

Вы можете использовать эту возможность когда вам нужен быстрый поиск по
дереву документа и не нужны dom-обертки.


## Встроенные UID маркеры под IE, :uid

В RightJS 2.0 мы использовали наш собственный секвенсор уникальных
идентификаторов для того чтобы поддерживать уникальность dom-оберток в
системе. Являясь вполне стандартным решением, данный подход имеет одну
проблему, такие идентификаторы появляются в виде нестандартных атрибутов
элементов в HTML контенте под браузерами Internet Explorer.

В RightJS 2.2 данная часть кода была переработана на использование встроенных
идентификаторов Internet Explorer, так что теперь мы больше не оставляем
никакого мусора на страницах.


## Устаревшие методы, :deprecations

Различные устаревшие методы были удалены из системы. Полный список следующ

    Element#select   -> Element#find
    Element#subNodes -> Element#children
    Element#sizes    -> Element#size
    Element#document -> Element#doc
    Element#window   -> Element#win

    Form#getElements -> Form#elements

    Document#select  -> Document#find

    Window#sizes     -> Window#size
    Window#onReady   -> Document#onReady

    new Wrapper      -> new Class

Если вы мигрировали свое приложение с RightJS 1 на RightJS 2, стоит проверить
код на предмет забытых методов.


## Оптимизация, :optimizations

Так же следует отметить некоторые обновления и оптимизации производительности.

Во-первых были оптимизированы многие процессы инициализации dom-оберток и
поиска по документам. Вы не заметите особых улучшений в простых тестах вроде
`TaskSpeed`, но данные изменения влияют на такие методы как {Element#match},
{Element#find}, {Event#find} и т.п., которые в свою очередь влияют на UJS и
скорость обработки событий в целом, и как следствие делают приложения более
отзывчивыми к действиям пользователя.

Во-вторых были оптимизированы многие внутренние процессы модуля {Fx}.
Многое зависит от каждой конкретной ситуации, но в целом рендеринг визуальных
эффектов стал плавнее и легче для браузеров. В Opera наш основанный на
javascript движок работает таже быстрее чем встроенные css-трансформации :)

В третьих, было произведено множество оптимизаций компрессии исходного кода.
Не смотря на достаточно большое количество новых возможностей и обновленного
функционала, конечный размер сборок практически не изменился.

RightJS 2.0 - `15.5k` gzipped

RightJS 2.2 - `15.6k` gzipped

И последнее немаловажное изменение заключается в том, что ядро и модули
RightJS были вычищены от всех `eval` и `document.write` хаков, так что теперь
его можно безопасно использовать с модными ныне асинхронными загрузками
javascript файлов вроде RequireJS и иже с ними.


&nbsp;

Это в общем-то все. Наслаждаемся!