# Unobtrusive программирование и делегация событий

Данная статья рассматривает вопросы написания ненавязчивых (unobtrusive)
скриптов с использованием техники делегации обработки событий

<%= anchors_index %>

## Что такое делегация событий?, :what

Делегация обработки событий это один из способов обработки DOM событий на
веб-страницах. Он использует эффект распространения (bubbling) событий по
дереву документа для того чтобы обрабатывать несколько элементов в одном
месте.

Для примера скажем у вас есть веб-страница со следующей структурой

    <html>
      <body>
        <ul id="todos">
          <li>Проснуться</li>
          <li>Побриться</li>
          <li>Покормить рыбок</li>
          <li>Захватить власть над миром</li>
        </ul>
      </body>
    </html>

Когда пользователь кликает на любом `LI` элементе, событие клика не
останавливается на элементе списка, а продолжает распространяться по структуре
документа, передаваясь во элемент `UL`, затем в `BODY`, `HTML` и в конце
концов попадает в объект документа.

Обычно мы подключаем слушателей событий непосредственно к нужным элементам и
обрабатываем события локально. Но мы с тем же успехом можем слушать события
на любом уровне, и затем в зависимости от того какой именно элемент вызвал
то или иное событие, вызывать соответствующий обработчик.


## Зачем это делать?, :why

Есть несколько причин зачем вам может понадобиться обработка событий с
делегацией.

Во-первых вы можете иметь большое количество элементов. Например если у вас
есть таблица размером 50х50 клеток и вам нужно единообразно обрабатывать клики
на всех из них. Вместо того чтобы подключать слушателей ко всем 2500 ячейкам,
вы можете подключить один единственный слушатель на уровне элемента самой
таблицы, что может во много раз уменьшить время инициализации вашего
приложения.

Второй типичный пример это динамический контент. Скажем вам нужно динамически
добавлять ячейки в таблицу из первого примера. Если вы подключаете слушателей
для каждой ячейки отдельно, то вместе с логикой создания новых ячеек вам нужно
будет позаботиться о соответствующей инициализации обработчиков событий, что
может серьезно усложнить программный код и замедлить приложение. В случае же
одного общего слушателя событий, все новые элементы будут обрабатываться
автоматически точно так же как и любые из тех что уже существуют в таблице.

Третье применение известно как "ненавязчивое (unobtrusive)
программирование". Идея его в том, что можно описать всю логику приложения в
одном месте на уровне документа, без непосредственного доступа и каких либо
изменений в самих элементах страницы. Это дает несколько преимуществ в дизайне
приложений, а так же позволяет создавать более или менее безопасные приложения
которые не влияют друг на друга.

Хорошим примером будут виджеты. Мы используем технику делегации событий во
многих виджетах из библиотеки RightJS UI, например Lightbox, Calendar,
Autocompleter и т.д. Это позволяет существенно сократить время инициализации
виджетов, дает им работать с динамическим контентом и инкапсулирует их логику
во всего нескольких обработчиках событий уровня документа.


## Простой пример, :example

Помните список задач из самого начала статьи? Предположим нам необходимо,
чтобы по клику на любом элементе списка, этот элемент переключал наличие
соответствующего css-класса. В случае RightJS код может выглядеть следующим
образом

    "#todos li".on('click', function() {
      this.toggleClass('marked');
    });

Этот простой кусок кода говорит документу следить за кликами и когда
пользователь кликает на элементе из списка, то вызвать нашу функцию в
контексте этого элемента.

На первый взгляд это может показаться немного странным, вызывать метод `on` на
строке,но если вы прочитаете сам код, то вы заметите, что он отлично читается.
Более того, метод `on` имеет точно тот же самый API что и метод {Element#on},
вы можете вызывать его с хэшами, списками и указывать обработчики по имени.

    "#todos li".on({
      click: function() {
        this.toggleClass('marked');
      }
    });

    // со списком обработчиков
    "#todos li".on('click', [
      function1, function2, function3
    ]);

    // с указанием обработчика по имени
    "#todos li".on('click', 'toggleClass', 'marked');

    // сокращения для стандартных событий так же доступны
    "#todos li".onClick('toggleClass', 'marked');

Вы можете думать об этом как о глобальном слушателе событий. Он делает все
тоже самое что и метод {Element#on}, только работает глобально на всех
элементах которые подпадают под указанное правило.


## Продвинутые возможности, :deeper

Забавный метод {String#on} на самом деле является просто шорткатом для метода
{Document#delegate}. Он просто подключает слушателя с делегацией событий на
уровень документа. Но в RightJS так же доступы другие методы, например
{Document#delegates} проверяет если документ делегирует обработку каких
либо событий, а метод {Document#undelegate} отключает делегацию событий

    $(document).delegates('click', '#todos li');
    $(document).undelegate('click', '#todos li');

Существуют так же дополнительные сокращения для класс {String} чтобы работать
с этими дополнительными методами. Они выглядят точно так же как подобные
методы класса {Element}

    "#todos li".observes('click');
    "#todos li".stopObserving('click');

И в конце концов, сам класс {Element} так же имеет свои собственные методы для
делегации событий {Element#delegate} и {Element#undelegate} что позволяет вам
подключать делегацию событий на любом уровне

    $('my-table').delegate('click', {
      'thead th': function() {
        // подсвечиваем колонку
      },

      'tbody td': function() {
        // подсвечиваем строку
      }
    });

Это может быть удобно в случае если вам необходимо обработать события на каком
то маленьком участке большого документа, не беспокоя остальные элементы дерева.


## Известные проблемы, :troubleshooting

Существует одна общая проблема с техникой делегации событий о которой вы
должны знать.

Т.к. данная техника использует эффект распространения события по дереву
документа, делегация обработки событий не будет работать, если событие было
остановлено где-то между источником и получателем. Например

    "#todos li".on("click", "toggleClass", "marked");

    $('todos').onClick(function(event) {
      event.stop();
    });

В данном случае, когда событие достигнет элемента `UL`, оно будет полностью
остановлено. Таким образом событие никогда не достигнет обработчика на уровне
документа и переключение класса не будет работать.

Если вы желаете отменить обработку события браузером по умолчанию, но при этом
хотите чтобы событие продолжало распространяться по документу, используйте
метод {Event#preventDefault} вместо {Event#stop}


