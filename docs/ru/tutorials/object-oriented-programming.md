# Объектно-ориентированное программирование

Внутренне, RightJS - объектно-ориентированный фреймворк и как следствие он предоставляет
расширенные возможности по объектно-ориентированному программированию. В данной статье
мы рассмотрим наиболее важные методики по работе с классами в RightJS.

<%= anchors_index %>


## Базовое определение, :definition

Базовое определение класса в RightJS выглядит точно так же каким вы можете его
увидеть в таких библиотеках как Prototype или Mootools. Точно так же существует
класс с именем {Class}, который используется следующим образом

    var MyClass = new Class({
      initialize: function() {
        // конструктор
      },

      method1: function() {},
      method2: function() {}
    });

Если вы имеете классы из Prototype/Mootools, которые не используют наследования,
они должны быть рабочими и в RigthJS тоже.


## Наследование, :inheritance

Наследование в RightJS выглядит похожим на наследование в Prototype, точно так же необходимо
указать два аргумента для {Class}, первый из них - родительский класс, а второй - хэш
методов для нового класса. Но разница в том, что в RightJS вместо того чтобы использовать
аргументы для ссылки на супер-методы, используется переменная с именем `this.$super`. Например:

    var Girl = new Class({
      sayHello: function() {
        return "привет";
      }
    });

    var FancyGirl = new Class(Girl, {
      sayHello: function() {
        return "Ну "+ this.$super() +" красавчег!";
      }
    });

Перегруженные методы в данном случае могут иметь любое количество аргументов любого рода,
и вы вольны вызывать родительский метод так, как вам это необходимо.


## Приватные методы, :private

RightJS не имеет никакой специальной функциональности для работы с приватными методами.
Потому что она в общем-то не нужна. Вы всегда можете создать приватные методы следующим
образом

    var MyClass = new Class((function() {

      var private_method = function() {
        // секретный код, недоступный снаружи
      };

    return {

        publicMethod: function() {
          // вы можете вызвать его как простую функцию
          private_method('bla', 'bla', 'bla');

          // или в контектсе объекта, как метод
          private_method.call(this, 'bla', 'bla', 'bla');
        }

    }})());

Идея очень проста, вы изолируете приватные методы во временной функции, которая возвращает
хэш для создания класса, и тут же ее вызываете.


## Модули в стиле Ruby, :mixins

Если вы когда либо работали с языком программирования Ruby, вы должны знать, как он использует
преимущества множественного наследования с помощью возможности создания совместно используемых
модулей и дальнейшей их инжекции в классы.

RightJS имитирует данную возможность и точно так же позволяет вам создавать совместно используемые модули

    var Module1 = {
      method1: function() {}
    };

    var Module2 = {
      method2: function() {}
    };

    var MyClass = new Class({
      include: Module1,
      extend:  Module2

      // дальше идут сами методы класса
    });

Принципы именования те же самые что и в Ruby, `include` расширяет уровень объекта (прототипа)
а `extend` расширяет уровень самого класса.

Вы так же можете указывать несколько модулей одновременно используя массивы

    var MyClass = new Class({
      include: [Module1, Module2, Module3],
      extend:  [Module4, Module5, Module6]
    });

Или используя непосредственно хэши вот таким образом.

    var MyClass = new Class({
      extend: {
        CLASS_LEVEL_CONST_1: 1,
        CLASS_LEVEL_CONST_2: 2,

        classLevelMethod: function() {

        }
      }
    });

А так же вы можете использовать методы класса `include()` и `extend()` _после_ того как
класс был создан

    var MyClass = new Class({});

    MyClass.include(Module1, Module2, ...);
    MyClass.extend(Module3, Module4, ...);



## Приоритеты методов модулей, :priorities

Есть два принципа которые вы должны держать в уме, работая с совместно используемыми модулями в RightJS

Когда вы подключаете ваши модули совместно с остальными методами класса _во время_
непосредственно определения. Методы класса будут иметь приоритет над методами модулей.

    var Module = {
      method: function() { return "метод модуля"; }
    };

    var MyClass = new Class({
      include: Module,

      method: function() {
        return "метод класса";
      }
    });

    new MyClass().method(); // -> "метод класса"

Но когда вы используете методы `include`/`extend` уже _после_ того как класс
был создан, в этом случае методы модулей будут иметь приоритет над методами
класса.

    var Module = {
      method: function() { return "метод модуля"; }
    };

    var MyClass = new Class({
      method: function() {
        return "метод класса";
      }
    });

    MyClass.include(Module);

    new MyClass.method(); // -> "метод модуля"



## Обратные вызовы, :callbacks

Имея систему классов на основе Ruby, RightJS так же поддерживает похожую систему обратных
вызовов для совместно используемых модулей. Что бывает очень полезно при метапрограммировании.

Для использования этой возможности, вам необходимо создать методы с именами `selfIncluded`/`selfExtended`
или в случае использования стиля с подчеркиваниями `self_included`/`self_extended`. Первый из них
вызывается когда модуль был использован для расширения уровня объекта, а второй соответственно при
расширении уровня класса. Обе функции получают ссылку на расширяемый класс.

    var Module = {
      self_included: function(klass) {
        klass.prototype.boo = 'boo';
      },

      self_extended: function(klass) {
        klass.BOO = 'BOO';
      }
    };

    var MyClass = new Class({
      include: Module,
      extend:  Module
    });

    MyClass.prototype.boo; // -> 'boo'
    MyClass.BOO;           // -> 'BOO'



## Предназначение методов, :prebind

Обычно, когда вы используете методы объекта в отличном от объекта контексте,
вам необходимо вручную назначить контекст исполнения этого метода. Например
у нас есть следущющий класс

    var Kid = new Class({
      initialize: function(name) {
        this.name = name;
      },

      whatsYourName: function() {
        alert(this.name);
      }
    });

    var ivan = new Kid('Ваня');

Теперь, если вы подключите метод `whatsYourName` как слушателя событий какого-либо
элемента, он не будет работать, т.к. метод будет исполнен в контексте самого элемента
и как следствие там не будет свойства `this.name`

    $('element').onClick(ivan.whatsYourName);
    $('element').fire('click'); // alerts 'undefined'

В данном случае вам необходимо вручную указать контекст исполнения метода

    $('element').onClick(ivan.whatsYourName.bind(ivan));
    $('element').fire('click'); // alerts 'Ваня'

Это все немного неудобно, люди часто забывают о данной особенности, что ведет к различным
багам и т.п. Чтобы избежать подобных проблем и сделать код немного чище и понятней, вы
можете указать классу автоматически предназначать контекст исполнения опредленному набору методов.
Делается это вот так

    var Kid = new Class({
      prebind: ['whatsYourName'], // список имен методов

      // остальная часть класса ....
    });

Как только вы указали ваш метод в списоке `prebind`, вы можете безопасно использовать его
где угодно.

    var ivan = new Kid('Ваня');

    $('element').onClick(ivan.whatsYourName);
    $('element').fire('click'); // alerts 'Ваня'


<p>&nbsp;</p>

<p>Это в общем-то все.</p>

