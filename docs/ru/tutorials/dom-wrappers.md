# DOM-обертки в RightJS 2

RightJS 1 был очень простой системой, мы просто расширяли родные dom классы
и всегда работали с элементами страниц напрямую, как есть. В каком-то смысле
это довольно удобно, но во многих ситуациях это рискованный подход, т.к.
возможны коллизии с другими скриптами на странице, а так же с собственными
методами браузеров.

И т.к. фреймворк у нас "правильный", начиная с версии 2.0.0 мы пошли 
правильным путем и полностью переключились с прямого доступа к элементам
страниц на использование dom-оберток.

<%= anchors_index %>

## Что-такое dom-обертки?, :what

Dom-обетка (dom-wrapper) это по сути объект-посредник, который хранит реальный
dom-объект внутри и предоставляет вам независимый интерфейс через который вы
уже, что называется, непосредственно и как бы это.

Таким образом мы храним все наши методы в изолированном пространстве и не 
изменяем родных типов dom, что в свою очередь дает другим скриптам на странице
работать с теми же элементами, не замечая нашего присутствия.

Dom-обертки так же дают стабильность в длительной перспективе, т.к. устраняют
вероятность того, что какой либо браузер в будущем добавит нестандартный метод
который создаст коллизию с нашими расширениями.



## Как это выглядит в RightJS?, :how

Dom-обертки в RightJS 2 имеют в точности тот же самый интерфейс что и 
dom-расширения в RightJS 1, благодаря чему выглядят и ощущаются в точности
так же как и код RightJS 1

    $('element').addClass('marked');
    
    $('element').onClick(function(event) {
      event.stop();
      this.toggleClass('marked');
    });
    
    $$('div.class').each(function(element) {
      element.addClass('my-element');
      // .....
    });
    
    $(raw_dom_element).removeClass('marked');

Все практически тоже самое, за исключением того факта, что теперь вместо
реальных dom-объектов вы имеете дело с объектами посредниками. И, как
результат, большинство вашего кода должно быть в рабочем состоянии после
миграции на RightJS 2

Существует так же и несколько различий. Во-первых, из-за того что теперь мы
работаем с объектами посредниками, вы не имеете прямого доступа к атрибутам
элементов и должны использовать методы {Element#get} и {Element#set}.

    $('element-id').id;        // -> null
    $('element-id').get('id'); // -> 'element-id'
    
    $('element').title;        // -> null
    $('element').set('title', 'Ура!');
    $('element').title;        // -> все еще null
    $('element').get('title'); // -> 'Ура!'

Второе небольшое отличие в том, что для доступа к расширениям объектов
`window` и `document` необходимо использовать функцию `$()`, так же как и со
всеми прочими элементами страницы

    window.sizes;       // -> null
    $(window).sizes;    // -> function
    
    document.onReady    // -> null
    $(document).onReady // -> function

Так же было добавлено несколько новых, дополнительных методов для класса
{Element}, для того чтобы помочь вам с различного рода атрибутами и ссылками.
Вы можете найти их список в статье о том
[что нового в RightJS 2](/tutorials/what-new-in-rjs2#new-dom-methods).



## Доступ к оригинальным dom-объектам, :raw

Когда вы работаете с вашим документом, RightJS будет автоматически и прозрачно
оборачивать все реальные dom-объекты когда вы их запрашиваете. Это включает
все dom-элементы, окна, документы и события.

Но не смотря на то что RightJS имеет отличнейший API, иногда вам может
понадобиться обратиться к оригинальному dom-объекту напрямую. Для этого, все
dom-обетки в RightJS имеют свойство `_`, которое и хранит ссылку на 
оригинальный объект.

    $('my-div')._  // -> DIV элемент
    $(window)._    // -> window объект
    $(document)._  // -> document объект
    
    $(element).onClick(function(event) {
      event._      // -> объект dom-события
    });

Это официальный и правильный способ, и вы можете всегда использовать его
когда нужно.


## DOM-обертки === классы, :classes

Переходим к интересным частям. А их у нас полно.

Все dom-обертки в RightJS создаются с помощью юнита {Wrapper}, который в свою
очередь является старым добрым юнитом {Class}, просто немного настроенным под
работу с dom-объектами. Это означает, что мы например имеем нормальные типы

    $('my-div') instanceof Element
    $(document) instanceof Document
    $(window)   instanceof Window

Обертки так же, как и все прочие классы поддерживают наследование. Для примера
мы имеет еще два класса в RightJS, {Form} и {Input}, один для управления
формами, второй для работы с полями ввода. Оба эти класса унаследованы от
базового для всех элементов страницы класса {Element} и вы можете корректно
работать с типами объектов с учетом наследования


    $('my-div') instanceof Element; // true
    $('my-div') instanceof Input;   // false
    $('my-div') instanceof Form;    // false
    
    $('my-form') instanceof Element; // true
    $('my-form') instanceof Input;   // false
    $('my-form') instanceof Form;    // true
    
    $('my-input') instanceof Element; // true
    $('my-input') instanceof Input;   // true
    $('my-input') instanceof Form;    // false

Вы так же можете использовать технику инжекции функциональности и расширять
каждый из классов раздельно, при этом все ваши расширения будут работать
согласно структуре наследования классов

    Element.include({
      // этот метод будет глобальным
      global_method: function () {}
    });
    
    Input.include({
      // этот метод появится только у полей ввода
      inputs_only_method: function() {}
    });
    
    Form.include({
      // этот метот будет доступен только с формами
      forms_only_method: function() {}
    });

Вы можете расширять таким способом любые dom-классы в системе: {Element},
{Input}, {Form}, {Window}, {Document}, {Event}



## Пользовательские типы, :custom

Система dom-классов RightJS, это открытая структура и вы можете легко 
добавлять ваши собственные типы которые будут обрабатывать элементы с
определенным тэгом. Например вы можете создать свой класс для управления
таблицами

    var Table = new Wrapper(Element, {
      sort: function() {
        // сортирует таблицу
      },
      
      load: function() {
        // заменяем базовый метод Element#load
        // так чтобы обновлялась только секция TBODY
      }
    });
    
    // регистрируем тип в системе
    Element.Wrappers.TABLE = Table;

После этого, если вы обратитесь к какой либо таблице на странице, она будет
использовать обертку нового типа

    $('my-table') instanceof Table;   // true
    $('my-table') instanceof Element; // true

Вы можете создавать классы для любых тэгов и добавлять/заменять любые методы
которые вам необходимы.



## Приватные обертки, :private

Вы можете создавать свои собственные типы, как это описано в предыдущей главе,
но на самом деле, dom-обертки в RightJS никак не привязаны к системе тэгов.
Вы можете создавать любое количество своих собственных приватных типов.
Например вы можете создавать два отдельных класса таблиц если хотите.

    var Table1 = new Wrapper(Element, {
      initialize: function() {
        this.$super('table', {'class': 'table-1'});
      }
    });
    
    var Table2 = new Wrapper(Element, {
      initialize: function() {
        this.$super('table', {'class': 'table-2'});
      }
    });
    
    var t1 = new Table1();
    var t2 = new Table2();

Это особенно удобно для создания различных виджетов. В RightJS 1 мы
создавали виджеты с мощью юнита {Class} и затем инкапсулировали реальный
элемент страницы внутри, например вот так:

    var MyWidget = new Class(Observer, {
      initialize: function() {
        this.element = new Element();
        
        this.element.onClick(this._clicked.bind(this));
      },
      
      insertTo: function(element, position) {
        this.element(element, position)
      },
      
      _clicked: function() {
        // делаем что-то по этому поводу
        this.element.addClass('clicked');
      }
    });

Такой подход рождает множество проблем из-за разницы контекстов, объекта
виджета и элемента страницы, вам так же необходимо было создавать множество
разных методов, так чтобы пользовательский скрипт мог работать с вашим 
виджетом и т.д. и т.п. Все эти вещи имеют тенденцию очень быстро выходить из
под контроля.

В RightJS 2 все иначе. Теперь вы можете определять ваши виджеты, как приватные
типы:

    var MyWidget = new Wrapper(Element, {
      initialize: function() {
        this.$super('div', {'class': 'my-widget'});
        this.onClick(this._clicked);
      },
      
      _clicked: function() {
        this.addClass('clicked');
      }
    });

Как вы можете видеть, это значительно упрощает код. Вы никогда не покидаете
контекст элемента т.к. виджет и есть {Element}. Как следствие он наследует
весь стандартный набор методов и пользовательские скрипты могут работать с
вашими виджетами как с любыми прочими элементами страницы

    var widget = new MyWidget();
    
    widget.addClass('custompization');
    widget.insertTo(document.body, 'top');
    widget.onClick(my_additional_handler);
    // и так далее ....

Все это позволяет создавать гораздо более простые и легкие в поддержке виджеты
чем раньше. Более того ваш код будет гораздо компактнее и более прост в
понимании.



## Кэширование оберток, :caching

И последний интересный момент в данной статье.

Когда вы работаете с dom-обертками, RightJS следит за созданием новых объектов
и затем автоматически использует их когда вы пытаетесь получить доступ к
элементам страницы, любым способом.

    var widget = new MyWidget();
    widget.set('id', 'my-widget');
    widget.insertTo(document.body);
    
    // возвращает правильный объект по ID
    $('my-widget') instanceof MyWidget; // true
    
    // или когда вы обращаетесь к нему любым другим способом
    $$('div.my-widget').last();         // -> MyWidget
    $(document.body).children().last(); // -> MyWidget
    ....

Для того чтобы удалить обертку из кэша, вы можете либо создать новую с тем
же dom-элементом, либо удалить кэш вручную по UID ключу.

    var widget = new MyWidget();
    widget.set('id', 'my-widget');
    
    $('my-widget') instanceof MyWidget; // true
    
    // заменяем обертку другой
    widget = new Element(widget._);
    $('my-widget') instanceof MyWidget; // false

    // удаляем кэш вручную
    var uid = widget.uuid();
    delete(Wrapper.Cache[uid]);

Это в общем то все что нужно знать для работы с обертками в RightJS.