# Функциональное программирование
<% set_unit_scope('Function') %>

Поддерживая несколько парадигм разработки, RightJS предоставляет несколько
стандартных для функционального программирования расширений, как-то биндинг,
карринг и цепи вызовов.


## Карринг, :currying

Карринг - это простой ФП концепт означающий следующее. Если вы имеете одну
функцию которая принимает некоторое число аргументов, вы можете создать
еще одну функцию которая будет автоматически устанавливать некоторые из этих
аргументов в заранее указанное значение.

Классический пример. Скажем вы имеете функцию которая перемножает два числа

    var multiply = function(x, y) {
      return x * y;
    };

    multiply(2, 3); // -> 6

На ее основе вы можете создать другую функцию которая будет автоматически
устанавливать первый аргумент равным `2` и как следствие будет всегда
удваивать входящие значения

    var double = multiply.curry(2);

    double(2); // -> 4
    double(3); // -> 6
    double(4); // -> 8

Или вы можете создать еще одну функцию которая будет возвращать утроенные
значения

    var triple = multiply.curry(3);

    triple(3); // -> 9

Основная идея в том, что по сути вы имеете одну функцию которая содержит
базовую логику и затем, на ее основе вы создаете другие функции основное
назначение которых предустанавливать определенные аргументы и создавать тем
самым различные версии базовой логики.


## Пример использования карринга, :curry_example

Карринг особенно удобен, когда у вас нет какого-либо подходящего места для
хранения переменных, или данные вам нужны только один раз, или вы вы желаете
создать несколько более простых версий одной и той же функции.

Простой пример. Скажем у вас есть некий список-меню и функция которая
записывает входящее число в лог.

    <ul id="menu">
      <li>Раз</li>
      <li>Два</li>
      <li>Три</li>
    </ul>

    var log_index = function(index) {
      console.log(index);
    };

И допустим вам необходимо подключить вашу функцию к каждому элементу списка
так, что по клику на него данная функция вызывалась с индексом кликнутого
элемента в списке.

Вы можете создать простую функцию которая будет находить индекс кликнутого
элемента в списке. Но что если скажем элементы списка могут быть
пересортированы в другом порядке, а вам необходимы индексы в оригинальном
виде?

Вы можете очень просто решить данную задачу используя карринг:

    $$('#menu li').each(function(item, index) {
      item.onClick(log_index.curry(index));
    });

В данном случае вы просто создаете несколько анонимных функций которые будут
хранить оригинальные индексы внутри и подставлять их в изначальную функцию
когда это необходимо.


## Левый и правый карринг, :left_and_right_curry

Существует два типа карринга, левый и правый. Левый карринг, это то что вы
только что видели, когда значения подставляются в список аргументов слева.
Правый же карринг это соответственно когда аргументы подставляются справа.
Например:

    var minus = function(x, y) {
      return x - y;
    };

    minus(4, 2); // -> 2

    // левый карринг
    var four_minus = minus.curry(4);

    four_minus(2); // -> 2
    four_minus(3); // -> 1

    // правый карриг
    var minus_four = minus.rcurry(4);

    minus_four(6); // -> 2
    minus_four(5); // -> 1

Как вы можете видеть, в первом случае мы отнимаем любое полученное число от
`4-х`, а во втором случае мы делаем обратное, отнимаем `4` от любого входящего
числа.


## Биндинг, :binding

Биндинг в случае ФП означает, что вы можете ассоциировать данную функцию для
того чтобы она была вызвана в контексте какого-либо определенного объекта.

Например, у нас есть два объекта представляющих двух людей и функция которая
создает полные имена данных персон.

    var karl = { firstName: 'Карл', lastName: 'Маркс' };
    var bill = { firstName: 'Билл', lastName: 'Гейтс' };

    var log_name = function() {
      console.log(this.firstName + " " + this.lastName);
    };

Обратите внимание, что наша функция ссылается на `this`, как если бы она была
непосредственной частью одного из объектов. В данном случае в JavaScript'е мы
можем вызывать данную функцию в контексте любого из объектов следующим
образом:

    log_name.call(karl); // -> 'Карл Маркс'
    log_name.call(bill); // -> 'Билл Гейтс'

Используя биндинг вы можете создать еще одну функцию которая будет вызывать
оригинальную в нужном контексте. Для примера скажем, если вы имеете две кнопки
и желаете чтобы по клику на одну из них браузер записывал "Карл Маркс" и по
клику на другую "Билл Гейтс".

Вы можете создать анонимную функцию вручную и вызывать нашу изначальную
функцию напрямую в нужном контексте, или же вы можете использовать метод
{#bind} для того чтобы сделать это автоматически

    karl_button.onClick(log_name.bind(karl));
    bill_button.onClick(log_name.bind(bill));

В данном случае вы изолируете оригинальную функцию и не смотря на то что
слушатели событий вызываются в контексте объекта данное событие вызвавшего,
когда вы используете биндинг вы можете быть уверены что ваша оригинальная
функция будет вызвана в указанном контексте.


## Биндинг + Карринг, :binding_and_currying

Биндинг и карринг зачастую используются совместно, и в RightJS вы можете
вызывать их одновременно.

Для примера, скажем у вас есть те же две кнопки "Карл" и "Билл"

    <input type="button" id="karl" value="Карл" />
    <input type="button" id="bill" value="Билл" />

Но в этот раз, ваша функция так же получает аргумент указывающий на то, что за
тип человека имеется ввиду

    var log_name = function(kind) {
      console.log(
        this.firstName + " " + this.lastName + " это " + kind
      );
    };

Вы можете использовать карринг одновременно с биндингом для решения проблемы

    $('karl').onClick(log_name.bind(karl, 'коммунист'));
    $('bill').onClick(log_name.bind(bill, 'капиталист'));

В данном случае, наша функция `log_name` будет вызвана в нужном контексте
и в тоже время получит предустановленный аргумент с типом.


## Биндинг + карринг + события, :binding_currying_and_events

Давайте копнем еще немного глубже. Скажем мы имеем все тоже самое что и в
предыдущем примере, но вместо кнопок у нас ссылки

    <a href="#" id="karl">Карл</a>
    <a href="#" id="bill">Билл</a>

В данном случае, для того чтобы предотвратить страницу от запрыгивания на
самый верх, нам необходимо остановить событие клика. Проблема в том, что
атрибут события всегда должен быть передан первым в списке аргументов.
Например вот так:

    var log_name = function(event, kind) {
      event.stop();
      console.log(...);
    };

Но если мы будем использовать биндинг и карринг одновременно, наша функция
будет получать указанную строку с типом человека вместо ожидаемого объекта
события.

Для подобных случаев класс {Function} имеет еще один метод называемый
{#bindAsEventListener}. Когда вы используете биндинг данным методом, вновь
создаваемая функция будет всегда подразумевать, что первый аргумент это объект
события и пропускать его на первое место где он и должен быть.

    $('karl').onClick(log_name.bindAsEventListener(karl, 'коммунист'));
    $('bill').onClick(log_name.bindAsEventListener(bill, 'капиталист'));

В данном случае непосредственный обработчик события будет пропускать аргумент
события вперед.

## Цепи вызовов, :chains

И последний в данной статье ФП концепт. Цепи вызовов.

Цепи вызовов служат для тех случаев когда вам необходимо вызвать несколько
функций в определенном порядке, одну за другой. Вы можете создавать цепи
используя метод {#chain}

    var first  = function() { console.log(1); };
    var second = function() { console.log(2); };
    var third  = function() { console.log(3); };

    var chain = first.chain(second).chain(third);

    chain(); // -> 1, 2, 3

Идея в том, что вы создаете новую функцию которая вызывает оригинальную
функцию а затем указанную. Потом еще одну и еще, так много как потребуется. В
конечном итоге вы получаете одну функцию которую можно безопасно передавать
подпрограммам и быть уверенным что все изначальные функции будут вызваны
строго в указанном порядке.

Вы так же можете совмещать цепи вызовов и карринг, например вот так

    var log_num = function(num) { console.log(num); };

    var chain = log_num.chain(log_num, 2).chain(log_num, 3);

    chain(1);  // -> 1, 2, 3

В данном случае мы имеет одну функцию, которую мы ставим в цепь вызовов саму
после себя несколько раз, но в каждом случае с разными аргументами.
