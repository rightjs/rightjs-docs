# Что нового RightJS 2

RightJS 2 это не обычное обновление функциональности, но большой шаг вперед
и по сути полный рестарт фреймворка. Мы взяли все самое лучшее из RightJS 1
и подняли на новый уровень.

Давайте же уже посмотрим на изменения!

<%= anchors_index %>


## DOM-Обертки (Wrappers), :wrappers

Идея dom-оберток проста, вместо того чтобы предоставлять прямой доступ к
элементам страницы, вы передаете пользователю объект-посредник, который уже
манипулирует элементом страницы находящимся внутри него. Делается это по
нескольким причинам, но основная из них в том, что мы больше не расширяем DOM
классы напрямую и как следствие имеем защиту от того что какой либо браузер в
будущем добавит что-то, что все нафиг сломает.

DOM-обертки в RightJS 2 работают прозрачно и имеют в точности те же самые
интерфейсы что и расширения которые мы использовали в RightJS 1. В общем
случае, вам не нужно изучать ничего дополнительного и код будет выглядеть
точно так же как он выглядел прежде

    $('element').onClick(function(event) {
      this.addClass('marked');
      event.stop();
    });
    
    $('element').onClick('toggleClass', 'marked');
    $$('div.class').each('onClick', 'addClass', 'marked');

Единственное большое отличие в том, что теперь у вас нет прямого доступа к
атрибутам элемента и необходимо использовать методы {Element#set} и
{Element#get}

    $('element-id').id;        // -> null
    $('element-id').get('id'); // -> 'element-id'
    
    $('element').title;        // -> null
    $('element').set('title', 'Ура!');
    $('element').title;        // -> still null
    $('element').get('title'); // -> 'Ура!'

Так же небоходимо использовать функцию `$()` для тоступа к объектам 
`document` и `window`

    window.sizes;       // -> null
    $(window).sizes;    // -> function
    
    document.onReady    // -> null
    $(document).onReady // -> function

Но это далеко не все. DOM-обертки в RightJS 2 по сути являются обычными
классами, с типами, наследованием и поддержкой инжекции функциональности.
И теперь с RightJS можно делать очень много разных, интересных штук.

Загляните в специальную
[статью о dom-обертках](<%=tutorial_path('dom-wrappers')%>)
а так же посмотрите
[что нового в RightJS UI 2](<%=tutorial_path('what-new-in-rui2')%>)


## Безопасный режим, :safe-mode

Второе по величине изменение в RightJS 2 это то как фреймворк 
инициализируется. Если RightJS 1 представлял собой по сути несколько скриптов
слееных вместе в глобальном пространстве, то RightJS 2 являет собой полностью
автономну структуру которая инициализируется в своем собственном пространстве.

Как и прежде, вы имеете доступ ко всем тем милым, коротким функциям, что и в 
RightJS 1, но теперь они просто ссылки на методы объекта `RightJS`. Сам же
фреймворк больше не зависит от глобальных функций, что в свою очередь дает вам
несколько интересных опций.

Во-первых это нормальный режим, который выглядит и работает точно так же как
RightJS 1. У вас есть глобальные функции, расширения ядра JavaScript и т.п.

Но теперь мы так же имеем сборки RightJS работающие в безопасном режиме. В
данном случае все что есть в глобальном доступе, это объект `RightJS` через
который вы можете вызывать весь остальной функционал.

    var element  = new RightJS.Element();
    var element  = RightJS.$('element-ids');
    var elements = RightJS.$$('div.class');

Безопасный режим создан для того чтобы RightJS мог работать с любыми другими
скриптами, например в случае разработки виджетов которые будут встраиваться на
чужие страницы. Поэтому в безопасном режиме RightJS _не расширяет_ ядро
JavaScript, но вы все равно можете воспользоваться всеми теми же расширениями
что и нормальном режиме, пропустив ваши данные через объект `RightJS`

    "За Родину!".endsWith;          // -> null
    RightJS("За Родину!").endsWith; // -> function
    
    (4).times;                      // -> null
    RightJS(4).times;               // -> function

И т.д.

RightJS так же предоставляет полубезопасный режим. Смысл идеи в том, что в
нормальном режиме все глоабальные функции, просто ссылки на методы объекта
`RightJS`, и это означает, что вы можете их все удалить или переназначить,
как вам заблагорассудится.

Посмотрите для примера плагин [jQuerish](/plugins/jquerysh), он изменяет
поведение функции `$()` на то к чему привыкли пользователи jQuery. Пользуясь
идеей полубезопасного режима, вы можете легко делать такие вещи с RightJS 2.

Загляните так же в специальную
[статью о безопасном режиме](<%= tutorial_path('safe-mode') %>), где все
описано более детально.


## Bubbling Events, :bubble

Если честно, то после dom-оберток, очень подмывает перевести заголовок как
"пузырящиеся события".

Как многие из нас знают, в JavaScript существует несколько проблемных событий,
как-то `submit`, `focus`, `blur` и `change`. Проблема с ними в том, что в 
некоторых браузерах они либо не всплывают по дереву документа вовсе, либо
всплывают, но не в ту сторону. Что естественно не делает жизнь разработчиков
легче.

RightJS в помощь! Он автоматически отлавливает, создает/исправляет, а затем
эмулирует всплытие этих событий по дереву документа, таким образом, что вам
нет решительно никакой нобходимости волноваться о них. У нас нет никаких
специальных имен или же специальных аргументов, или какой бы то ни было прочей
порочащей несуразности. Просто пишите ваш код так, как будто все события
добрые и хм... пушистые?

    $('element').on({
      blur:   function() { },
      focus:  function() { },
      change: function() { },
      submit: function() { }
    });

Более того, в RightJS 2 все искуственные события так же всплывают и вы можете
работать с ними в точно том же порядке как и с любыми другими событиями.



## Новый API делегации событий, :events-delegation

В последних версиях RightJS 1.5 уже имел некоторые элементы функциональнсти
для делегации обработки событий. RightJS 2 продолжает развитвать это
направление и предоставляет новый, более полный интерфейс.

Во-первых, класс {String} теперь имеет все те же методы для работы с событиями
что и класс {Element}. Если в RightJS 1 это был всего лишь один метод
{String#on}, то теперь вы имеете весь набор

    // сокращения для стандартных событий
    "div.class".onClick(function() {...});
    
    // работает с проблемными событиями
    "div.class".onFocus('addClass', 'hovered');
    "div.class".onBlur('removeClass', 'hovered');
    
    // работает с искусственными событиями
    "div.class".on('my-event', 'addClass', 'my-class');
    
    // можно проверять если событие обрабатывается
    "div.class".observes('click');   // -> true
    
    // и можно отключить ненужные осбытия
    "div.class".stopObserving('click');

И это еще не все. Класс {Element} получил полностью новый API специально
предназначеный для делегации обработки событий. Теперь вы можете обрабатывать
события не только на уровне документа, но и вообще на уровне любого удобного
вам элемента

    $('my-list').delegate('click', {
      'li.completed':  completed_items_handler,
      'li.incomplete': incomplete_items_handler,
      ...
    });
    
    // можно проверять делегируются ли события
    $('my-list').delegates('click'); // -> true
    
    // и можно так же отключать делегацию событий
    $('my-list').undelegate('click');

Для более детальной информации смотрите
[API документацию](/docs/element#delegate) и
[статью о делегации событий](<%= tutorial_path('events-delegation') %>)


## Поддержка работы с фреймами, :frames

Благодаря dom-оберткам и безопасному режиму, RightJS теперь официально и
полностью подерживает работу с фреймами. В целом все работает совершенно
прозрачно по отношению к API, и вы можете управлять элементами другого фрейма
точно так же как и элементами основной страницы.

    $(other_document).find('div.class').each(function(element) {
      element.onClick('toggleClass', 'marked');
    });



## Поддержка JSONP

В дополнение к XHR и IFramed тунелям, класс {Xhr} так же получил поддержку
JSONP формата из коробки. Все что вам нужно для того чтобы сделать jsonp
запрос, это указать опцию `jsonp`n

    Xhr.load('/mysite.json', {
      jsonp:      true,
      spinner:    'my-spinner',
      onComplete: function() {
        // данные JSON доступны в обычном порядке
        allert(this.json.somstuff);
      }
    });

Вы так же можете указать любое другое имя для параметра обратного вызова,
вместо стандартного значения `true`. Все прочие вещи работают точно так же
как и для любых других {Xhr} запросов.



## Новые DOM методы, :new-dom-methods

Т.к. RightJS 2 переключился с прямого доступа к элементам страницы на
dom-обертки, это открыло путь для множества новых возможностей и методов,
которые ранее нельзя было использоваться из-за конфликтов с именами
родных методов.

Некоторые методы были просто переименованы (старые имена будут так же
доступны еще некоторое время):

 * {Element#select} -> {Element#find}
 * {Element#subNodes} -> {Element#children}
 * {Element#sizes} -> {Element#size}
 * {Window#sizes} -> {Window#size}
 * {Document#select} -> {Document#find}
 * {Form#getElements} -> {Form#elements}

Так же было добавлено несколько новых методов

 * {Element#html} - двунаправленый метод для доступа к свойству `innerHTML`
 * {Element#append} - сокращение для {Element#insert}
 * {Element#clone} - полностью клонирует элемент
 * {Element#document} - возвращает ссылку на {Document} элемента
 * {Element#window} - возвращает ссылку на {Window} элемента
 * {Form#input} - возвращает {Input} по имени
 * {Form#submit} - прокси для form.submit метода
 * {Form#reset} - прокси для form.reset метода

Класс `Form.Element` был переименован в {Input}. Так же теперь он имеет
унифицированный конструктор в котором вы можете указывать разные значения
опции `type`

    new Input(); // type == 'text' по умолчанию
    new Input({type: 'password'});
    new Input({type: 'textarea'});
    new Input({type: 'select'});
    new Input({type: 'multi-select'});

Класс {Input} так же имеет несколько новых дополнительных методов

 * {Input#form} - возвращает ссылку на объект {Form}
 * {Input#value} - двунаправленый метод для доступа к данным поля
 * {Input#disabled} - возвращает статус свойства `disabled`
 * {Input#checked} - возвращает статус свойства `checked`

Так же для класса {Element} был добавлен полностью новый API для делегации
обработки событий. Он описан парой разделов выше.


## Новые методы ядра JavaScript, :new-js-methods

Классы ядра JavaScript так же получили несколько новых удобных методов

 * {Array#reject} - обратный метод для {Array#filter}
 * {Array#min} - возвращает наименьшее число в массиве
 * {Array#max} - возвращает наибольшее число в массиве
 * {Array#sum} - возвращает сумму чисел в массиве
 * {Number#min} - ограничивает число снизу до указанного значения
 * {Number#max} - ограничивает число сверху до указанного значения



## Назначение методов, :prebind

Классы {Class} теперь позволяют вам указать, что некоторые методы должны
всегда исполняться в контексте объекта которому они принадлежат. Идея очень
простая, например вы имеете объект некоего класса и используете его методы
в другом контексте, в этом случае вам нужно всегда вызывать метод `bind`
для того чтобы закрепить текущий контекст

    var Klass = new Class({
      name: 'Klass'
      alert: function() {
        alert(this.name);
      }
    });
    
    var inst = new Klass();
    
    $('element').onClick(inst.alert.bind(inst));

Это довольно неудобно, иногда вы забываете указать нужный контекст, что 
приводит к багам и потерянному времени.

Теперь вам больше не нужно об этом волноваться, т.к. вы можете просто указать
список методов и класс автоматически назначит им соответствующий контекст

    var Klass = new Class({
      prebind: ['method1', 'method2', 'method3']
    });

После этого вы можете использовать указанные методы где и как угодно, они
они всегда будут исполняться в контексте объекта которому принадлежат.

Загляните так же в [OOП статью](/tutorials/object-oriented-programming) где
есть более развернутая информация о работе с классами в RightJS.



## Улучшение производительности, :performance

Практически каждая новая версия RightJS выходит с теми или иными улучшениями
производительности, помогая держать RightJS на вершине списка самых быстрых
библиотек. Естественно RightJS 2 не стал исключением.

Во-первых были оптимизированы важные вещи, такие как dom-манипуляции и
подключение слушателей событий. В некоторых браузерах это более заметно, в
некоторых менее, но если судить по последним версиям FF и Opera, мы имеем
на 25% более быстрые методы по сравнению с RightJS 1.5.6.

Процесс создания элеметов в Opera стал быстрее примерно на 30%, а благодаря
переходу на dom-обертки, производительность создания и доступа к элементам в
браузерах IE6/7 выросла в несколько раз.

Загляните на очень популярную [страницу бенчмарков](/benchmarks) там все есть.



## Новая система сборки и оптимизация размеров, :packing

Со всеми новыми плюшками и погремушками, RightJS 2 естественно увеличился в
размерах, поэтому были произведены кое какие манипуляции для преведения его
в чувства.

Во-первых, теперь RightJS инициализируется в закрытом пространстве имен, что
позволило сэкономить на различных приватных переменных. Во-вторых, мы
переключились с FrontCompiler на более эффективный Google's Closure Compiler,
в третьих решено было отказаться от пакованых версий сборок и 
сконцентрироваться на том, как файлы лучше сжимаются gzip'ом

Результаты следующие:

RigthJS 1.5.6 весит 42k в min сборке и 14.5k в gzip'е.
RightJS 2.0.0 весит 44k в min сборке и 15.5k в gzip'е.

Что, думаю очень неплохой обмен, учитывая всю новую функциональность.

За сим позвольте мне откланяться и пожелать всем новых свершений.