# Класс
[Prototype]: http://prototypejs.org
[Mootools]:  http://mootools.net
[Ruby]:      http://www.ruby-lang.org

RightJS - объектно-ориентированная библиотека, и соотетственно
предоставляет расширенные возможности для объектно-ориентированного
программирования. Классы в RightJS представляют собой смесь идей из
библиотеки [Prototype][] и языка программирования [Ruby][].


## Базовое определение

Базовое определение класса в RightJS выглядит точно так же как оно выглядит
в библиотеках [Prototype][] и [Mootools][]

    var Klass = new Class({
      initialize: function() {
        // constructor
      },

      method1: function() {},
      method2: function() {}
    });


## Наследование

Наследование в RightJS похоже на наследование в библиотеке [Prototype][],
точно так же нужно передать два аргумента, базовый класс и методы нового
класса. Разница только в том, что в RightJS для обращения к методам
родительского класса используется переменная `this.$super`

    var Girl = new Class({
      sayHello: function() {
        return "Hello there";
      }
    });

    var SexyGirl = new Class(Girl, {
      sayHello: function() {
        return "Well "+ this.$super() + "!";
      }
    });


## Модули в стиле Ruby

Язык [Ruby][] использует преимущества множественного наследования путем
возможности создавать независимые модули, и далее вставлять их в тело
любого класса, позволяя тем самым совместное использование неограниченного
количества модулей несколькими классами.

Библиотека RightJS предоставляет ту же самую функциональность в классах
JavaScript

    var Module = {
      method: function() {}
    };

    var Klass = new Class({
      include: Module, // <- добавить модуль на уровень объекта
      extend:  Module, // <- добавить модуль на уровень класса

      // остальные методы класса
    });

Вы так же можете вставлять несколько модулей одновременно, с помощью массивов

    var Klass = new Class({
      include: [Module1, Module2, ...],

      // или на уровне класса
      extend:  [Module1, Module2, ...]
    });

Можно так же определять объекты непосредственно в теле класса, что позволяет
естественным образом описывать константы и методы уровня класса в одном куске
кода с методами уровня объекта

    var Klass = new Class({
      extend: {
        CLASS_LEVEL_CONST_1: 1,
        CLASS_LEVEL_CONST_2: 2,

        classLevelMethod: function() {}
      },

      // методы уровня объекта
    });

Еще вы можете вызывать методы `include()` и `extend()` после того как
класс был уже определен.

    var Klass = new Class({
      // ....
    });

    Klass.include(Module, Module, ...);
    Klass.extend(Module, Module, ...);

__ВНИМАНИЕ:__ приоритет вставляемых модулей в RightJS работает точно в том же
порядке, как это происходит в языке программирования [Ruby][]. Т.е. если вы
вставили модуль во время определения класса, то собственные методы класса
будут иметь приоритет над методами модуля. Но если вы вставляете модуль,
используя методы `include()` и `extend()`, _после_ того как класс был
инициализирован, то методы модулей будут установлены поверх методов класса.


## Обратные вызовы для модулей

Предоставляя похожую на [Ruby][] функциональность для работы с модулями,
RightJS, аналогичным образом, дает возможность для обработки обратных вызовов
во время вставки модулей в классы. В RightJS имена сохранены похожими на
условные имена в [Ruby][]: `selfIncluded` и `selfExtended`. Или в случае
использования стиля с подчеркиваниями `self_included` и `self_extened`

    var Module = {
      selfIncluded: function(klass) {
        klass.prototype.foo = 'bar';
      },

      selfExtended: function(klass) {
        klass.FOO = 'BAR';
      }
    };

    var Klass = new Class({
      include: Module,
      extend:  Module
    });

    Klass.prototype.foo; // -> 'bar'
    Klass.FOO;           // -> 'BAR'


Вы можете так же заглянуть в специальную
[статью по ООП](/tutorials/object-oriented-programming) с более детальными
описаниями.
